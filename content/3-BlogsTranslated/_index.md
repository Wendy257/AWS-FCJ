---
title: "Translated Blogs"
 
weight: 3
chapter: false
pre: " <b> 3. </b> "
---

###  [Blog 1 - Zupee implements Amazon Neptune to detect Wallet transaction anomalies in real time](3.1-Blog1/)
This blog describes how Zupee implemented Amazon Neptune, a graph database, to detect wallet-transaction anomalies in real time by modeling users, devices, and payment methods as interconnected nodes and relationships. You will learn why traditional relational databases struggle with highly connected data and how graph queries enable quick detection of suspicious patterns such as shared devices, linked accounts, or abnormal transaction behaviors. The article explains the real-time pipeline that processes over a million daily transactions with low-millisecond latency, helping Zupee reduce fraud, strengthen user trust, and scale its gaming platform efficiently.

###  [Blog 2 - Modernize .NET applications at scale with AWS Transform for .NET](3.2-Blog2/)
This blog introduces how organizations can modernize legacy .NET Framework applications by using AWS Transform for .NET to automatically port them to modern, cross-platform .NET versions such as .NET 8. You will learn why modernization reduces licensing costs, removes Windows dependencies, and improves cloud readiness. The article explains how the tool scans repositories, analyzes dependencies, upgrades projects, resolves compatibility issues, and generates reports to accelerate porting. It also shows how teams can orchestrate modernization at scale across multiple applications, improving maintainability, performance, and long-term sustainability of their .NET workloads.

###  [Blog 3 - SQL to NoSQL: Planning your application migration to Amazon DynamoDB](3.3-Blog3/)
This blog explains how to plan the migration of an application from a relational SQL database to Amazon DynamoDB by analyzing your existing schema and data-access patterns. It clarifies the key differences between SQL and NoSQL, why denormalization and access-patternâ€“driven design are necessary, and how to break down tables, relationships, and queries to redesign your data model for DynamoDB. The article walks you through examining usage metrics, identifying read/write patterns, and choosing partition/sort keys or secondary indexes to meet performance and scalability goals. You will also learn how to approach migrations in microservices environments and ensure that the new NoSQL model maintains efficiency, correctness, and cost-effectiveness at scale.
